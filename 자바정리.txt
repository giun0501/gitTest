Part1. 변수
변수 : 값을 저장하는 공간 / 메모리에 값을 저장(메모리할당 (동적할당/정적할당))
int float = 4byte
short : 2byte
double : 8byte

1. 원시변수
원시변수 : 할당된 데이터의 실제값이 저장되는 변수
int = 0 ;

2. 참조변수
할당된 데이터의 주소값이 저장되는 변수
String은 참조변수
String name = "John";
위 코드에서 name은 String 타입의 참조 변수입니다. "John"이라는 문자열 데이터는 문자열 풀(String Pool)이라고 불리는 메모리 영역에 저장되고, 
name 변수는 해당 문자열 데이터를 가리키는 주소를 갖게 됩니다.

3. 배열
같은 타입의 변수들로 이루어진 집합 / 고정적인 길이를 가진다. / 연속적으로 기억공간을 할당 / 순서가 있는 자료형이다.
int a[] = new int[10];
4. Integer vs int
integer : int의 wrapper class로 기본자료타입을 객체로 다루기위해 사용 
int는 null값을 가질수없지만 integer는 null값을 가질수 있다.
ex)Integer.parseInt()
int : 정수형 변수의 타입
int a = 0;
Part2. 연산자
1. 연산자종류
대입연산자(=),비교연산자(<,>,==,!=,<=,>=),논리연산자(true,false,||,&&),산술연산자(+,*,-,/..)

2. 연산자 우선순위
괄호 > 산술 > 비교 > 논리 > 대입
Part3. 명령문

1. 조건문(if)
참과 거짓을 판단하는 문장으로 조건에 따라 진행되는 부분이 다름
if(a > 20){
      break;
}
2. 반복문(for,while)
코드가 중복되는 부분을 반복문을 사용해 코드의 반복을 줄여주는 역할을 한다
for(int i = 0 ; i < 10 ; i++){

3. for문과 while문의 차이
for : 초기값과 조건식 증감연산으로 이루어져있으며 동작을 실행 ,조건식으로 true false 판단 / 횟수를 가지고 반복
for(int i = 0 ; i < 10 ; i++){
while: 조건식이 false가 될때까지 진행 ,조건식이 필수적임 / 조건을 가지고 반복
while(true){ / while(cnt-- <= 0){

Part4. OOP
1. 객체지향언어 특징 3가지
다형성/상속/캡슐화/추상화
다형성 : 같은이름의 메소드를 호출하더라도 객체에 따라 다르게 동작 (메소드 오버라이딩 ,메소드 오버로딩)하기때문에 코드의 재사용성이 높아짐 /
상위클래스에서 하위클래스로 접근이 가능하다.
상속과 인터페이스 같은경우 슈퍼클래스나 인터페이스 클래스로부터 하위클래스의 접근이 가능하다.

캡슐화 : 클래스안의 연관된 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호함(싱글톤) /은닉화 : 접근제어자

추상화 : 각 클래스의 공통적인 부분을 뽑아 상위클래스화 시키는것(상위가아니라 하위도 가능) / 
현실이나 사물을 클래스로 정의한 것 / 
데이터를 처리하는 함수를 모아놓은 모듈
public interface abc{
	public int abcde(int a);
}
상속 : 부모클래스의 기능을 자식클래스에게 상속받아 자식클래스에서도 사용할 수 있는것
public class Vehicle {
	protected int speed = 3;
	
	public int getSpeed(){
		return speed;
	}
}

public class car extends Vehicle{
	public void printspd(){
		System.out.println(speed);
	}
}
결과 : 3

public class abcd implements abc{  //다중상속을 지원하지않는 대신 implements 사용, 반드시 재정의 필요
	public int abcde(int a){
		int b = a + 1;
		return b;
	}
}


2. 객체란 무엇인가?
객체(Object)란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른것과 식별 가능한 것을 말합니다.
객체는 속성과 동작으로 구성되어 있다고 보면 되는데 자바에서는 이 속성과 동작을 각각 필드(field) 와 메소드(method) 라 부릅니다.

3. 객체를 초등학교 수준으로 설명하시오
클래스 == 붕어빵 틀
붕어빵

4. 다형성이란 무엇인가?
-메소드 오버라이딩 ,메소드 오버로딩
메소드 오버로딩 : 같은이름의 메소드를 매개변수에 따라 다르게 동작하게 하는것
public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }

메소드 오버라이드 : 
class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Dog barks");
    }
}
5. 상속과 인터페이스를 설명
상속은 부모클래스를 물려받아 부모클래스의 기능들을 사용할 수 있어 코드의 재사용을 도와주지만 다중상속이 불가능하다.(extends) / 슈퍼클래스의개념을 서브클래스로 확장하는 개념
인터페이스는 클래스가 어떤 메소드를 제공하는지를 정의 다형성을 이용해 구현 인터페이스는 다중상속이 가능하다(implements) / 기능을 구체화시킨것 (구현)

class 부모클래스 {
    // 멤버 변수와 멤버 메서드 정의
}

class 자식클래스 extends 부모클래스 {
    // 자식 클래스의 추가 멤버 변수와 멤버 메서드 정의
}


interface 인터페이스 {
    void 메서드1();
    void 메서드2();
}

// 인터페이스를 구현하는 클래스
class 구체클래스 implements 인터페이스 { //재정의 필요

    public void 메서드1() {
        // 메서드1 구현
    }

    public void 메서드2() {
        // 메서드2 구현
    }
}
6, 추상클래스가 무엇인가?
추상메소드는 정의만하고 구현하지 않은것 오버라이드해서 사용 추상메소드가 하나라도 있으면 추상클래스라고 한다.
상속을 통해서 하위 클래스에서 (반드시) 구현하도록 강제하는 클래스입니다.
abstract로 선언된 추상 클래스는 상속을 위한 클래스이기 때문에 new 키워드를 통해 직접 객체를 생성할 수 없다
인터페이스와 다르게 static이나 final이 아닌 필드를 가질 수 있고, public protected, private 접근 제어자를 모두 사용할 수 있습니다.

인터페이스는 추상 클래스보다 추상화 정도가 높으며 추상 클래스와는 다르게 구현부가 있는 일반 메서드, 일반 멤버 변수를 가질 수 없다는 특징이 있습니다.
7. 싱글톤
-어플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당 그메모리에 인스턴스를 만들어서 사용하는 디자인 패턴
예를들어 여러군데 객체가 생성되면 설정값이 변경될 위험이 크다
이런이유로 인스턴스가 한개만 생성되는 특징인 싱글톤을사용하면 요청이 많은곳에서 사용하면 효율을 높일수 있다.

싱글톤의 이점
-고정된 메모리영역을 얻으면서 new로 인스턴스를 사용해 메모리낭비 방지
싱글톤은 전역클래스이기 때문에 다른클래스간의 공유가 쉬움
인스턴스가 절대적으로 한개만 존재한다는것을 보증하고싶을때 사용
두번째 이용시부터는 객체로딩시간이 줄어 성능이 좋아지는 장점이 있음

단점 싱글톤이 너무많은 일을하거나 데이터를 공유할경우 다른클래스의 인스턴스들간의 결합도가 높아져 개방폐쇠원칙을 위배
수정이어렵고 유지보수 비용이 높아질 수 있음

데이터베이스에서 커넥션풀, 스레드풀, 캐시, 로그 기록 객체 등


Part5. 자료구조
1. Collection
여러개의 객체를 담는 프레임워크<List,Map,Set>
2. stack
선입후출의 자료구조 (FILO) STACK AREA(호출된 메소드 저장 ,지역변수,매개변수등 저장)  HEAP AREA () , 
3. queue
Part6. 기타 중요한 이론
1. JVM(자바의 메모리 영역), 가비지컬렉터
Method Area: 클래스 정보(메타데이터)를 저장하는 영역으로, 클래스 로더에 의해 로드된 클래스들의 코드, 상수, 필드, 메서드, 인터페이스 등의 정보가 저장됩니다.

Heap: 객체 인스턴스와 배열 등의 동적으로 생성된 데이터를 저장하는 영역입니다. Java에서는 new 키워드를 사용하여 객체를 생성하면 Heap에 할당됩니다.

Stack: 메서드 호출과 함께 생성되는 지역 변수, 매개변수, 임시 데이터 등을 저장하는 영역입니다. 각 스레드마다 별도의 스택이 생성됩니다.

PC Register (Program Counter Register): 현재 실행 중인 스레드의 실행 위치(다음 실행할 명령어의 주소)를 저장하는 영역입니다.

Native Method Stack: Java 외의 언어(C, C++ 등)로 작성된 Native 메서드들을 실행하는 데 사용되는 스택 영역입니다.

Execution Engine에 의해 해석된 기계어 코드가 실제로 실행되는 영역은 여러 영역에서 동작합니다. 메서드 영역과 힙 영역은 JVM이 시작될 때 생성되고, 스택 영역은 각 스레드가 생성될 때마다 할당됩니다.
2. static, final

static : 객체생성없이 필드나 메소드를 사용할 수 있는 공용 변수

final : 변수의 값 수정불가능  
3. 오버라이딩(Overriding)과 오버로딩(Overloading)
오버라이딩 : 메소드를 재정의 / 추상메소드는 반드시 재정의 해야함
오버로딩 : 메소드의 이름은 같지만 매개변수에 따라 하는 기능이 달라짐 
4. String, StringBuffer, StringBuilder° ≥70)
String : 값을 변경할 수 없음 / 만약 값이 변경된다면 새로운 객체가 만들어지는 것이다. 성능이 저하될 우려가 있다.
이것을 개선하기위해 StringBuffer 와 StringBuilder가 있다.
StringBuffer 와 StringBuilder의 차이 //멀티쓰레드
StringBuffer 는 동기화 제공
StringBuilder는 동기화 미제공



5.접근제어자
필드, 메서드, 내부 클래스 등)에 대한 접근 범위를 지정하는 키워드입니다.
변수 
6. error, Exception 차이
error : 컴파일도 불가능한 상태
exception : 실행할때 동작중에 나오는 오류
